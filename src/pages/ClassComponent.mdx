import {
  PlainPropsClassComponent,
  ObjectPropsClassComponent
} from '../examples/components/ClassComponent.tsx';

## Class Component

**Class Component** - the component which extends [`React.Component`](https://reactjs.org/docs/react-api.html#reactcomponent) and uses OOP paradigms to handle state, properties, actions and manage component lifecycle. React component re-renders if the parent component got re-rendered even if no props were changed.

### Regular Component - Plain props

```tsx
export class ChildClassComponent extends Component<TValue> {
  render() {
    // if parent component updates this component will be re-rendered üí£,
    // no matter if the props have been changed or not.
    return (
      <RenderCounter color="red">
        Child Class Component: {this.props.value}
      </RenderCounter>
    );
  }
}
```

<PlainPropsClassComponent isMemoized={false} />

### Solution 1: Override `shouldComponentUpdate()` lifecycle method

```tsx
export class ChildClassComponentMemoized extends Component<TValue> {
  // ‚úÖ place the logic to detect if component should update or not.
  shouldComponentUpdate(nextProps: Readonly<TValue>) {
    // üí° the logic here might become very complicated,
    // make sure you split components to the small or
    // consider using Pure or Function components.
    return nextProps.value !== this.props.value;
  }

  // ‚úÖ the component re-renders only if props have been changed.
  render() {
    return (
      <RenderCounter color="red">
        Child Class Component <strong>Memoized</strong>: {this.props.value}
      </RenderCounter>
    );
  }
}
```

<PlainPropsClassComponent isMemoized={true} changeProps={false} />

and it re-renders as expected, when props have been changes.

<PlainPropsClassComponent isMemoized={true} changeProps={true} />

### Solution 2: Use Pure Component

Consider using Pure Component.

```tsx
export class ChildPureComponent extends PureComponent<TValue> {
  // `Pure` component implements `shouldComponentUpdate()` with a shallow prop and state comparison.
  // That means no additional changes needed for the plain props.
  // ‚úÖ Component does not re-render if parent component re-renders
  // but the props have not been changed.
  render() {
    return (
      <RenderCounter color="green">
        Child Pure Component: {this.props.value}
      </RenderCounter>
    );
  }
}
```

---

### Regular Component - Object props

Passing objects as properties to the component are dangerous in terms of causing not wanted re-rendering.
If component needs to work only with subset of the object properties and none of them being changed,
the component still might re-render if any of the other property has changed.

Also, even if developer created the object and passes it as a parameter to the component,
it doesn't prevent other developers to add their own properties to the same object without
even knowing that it might have negative impact on re-rendering some other not related component.

```tsx
export type TObjectProps = {
  obj: TObjectValue;
};

export type TObjectValue = {
  num: number;
  str: string;
};
```

The component takes object properties as defined above:

```tsx
export class ChildClassComponentWithObjectProps extends Component<
  TObjectProps
> {
  render() {
    // The component only works with ‚úÖ obj.str property and ignores ‚úÖ obj.num
    // If parent component doesn't change the ‚úÖ obj.str, but changes ‚õî obj.num
    // this component will still re-render üí£
    return (
      <RenderCounter color="red">
        Child Class Component: {this.props.obj.str}
      </RenderCounter>
    );
  }
}
```

When parent component changes `obj.num` and doesn't change `obj.str`, the component
still re-renders.

<ObjectPropsClassComponent isMemoized={false} />

### Solution 1: Use plain props

The best solution is to use plain props and pass primitive values to the component.

```tsx
export class ChildClassComponentWithObjectProps extends Component<{
  str: string;
}> {
  // ‚ùó even is you use plain props, make sule you also override shouldComponentUpdate()
  // othervise force update will trigger re-rendering.
  shouldComponentUpdate(nextProps: Readonly<{ str: string }>) {
    return nextProps.str !== this.props.str;
  }

  render() {
    // ‚úÖ No object which can impact re-rendering
    return (
      <RenderCounter color="red">
        Child Class Component: {this.props.str}
      </RenderCounter>
    );
  }
}
```

### Solution 2: Override `shouldComponentUpdate()` lifecycle method

When parent component changes `obj.num` and doesn't change `obj.str`, the component
**does not** re-render.

```tsx
export class ChildClassComponentWithObjectPropsMemoized extends Component<
  TObjectProps
> {
  shouldComponentUpdate(nextProps: Readonly<TObjectProps>) {
    // ‚úÖ Make sure you cover scenario, when other developer
    // could potentially add other fields to the props object
    return nextProps.obj.str !== this.props.obj.str;
  }

  render() {
    return (
      <RenderCounter color="red">
        Child Class Component <strong>Memoized</strong>: {this.props.obj.str}
      </RenderCounter>
    );
  }
}
```

<ObjectPropsClassComponent isMemoized={true} changeProps={false} />

but when parent component changes `obj.str` re-rendering happens, as expected:

<ObjectPropsClassComponent isMemoized={true} changeProps={true} />

---

### Regular Component - Method Component

Method Component is a component which was implemented as a **method of Class Component**.
Implementing components this way will cause several issues:

- Hard to maintain, components become tightly coupled
- Hard to control re-rendering conditions
- Hard to reuse such components
- Idiomatically React is functional and the approach is rather OOP
- Potentially may cause hooks related bugs (https://kentcdodds.com/blog/dont-call-a-react-function-component)

```tsx
interface IProps {
  str: string;
  num: number;
}
class ClassComponent extends Component<IProps> {
  firstComponent = () => {
    return (
      <RenderCounter color="blue">
        Child Class Component: "{this.props.str}"
      </RenderCounter>
    );
  };
  secondComponent = () => {
    return (
      <RenderCounter color="green">
        Child Class Component: {this.props.num}
      </RenderCounter>
    );
  };

  render() {
    return (
      <RenderCounter color="red">
        {this.firstComponent()}
        {this.secondComponent()}
      </RenderCounter>
    );
  }
}
```

### Solution: Separated Components

Every component has its scope and depends only on required props.
It allows us to easily refactor/remove a component and specify re-render conditions
for each component separately using `React.PureComponent`, `shouldComponentUpdate()` or `React.memo()`

```tsx
interface IFirstComponentProps {
  str: string;
}
class FirstComponent extends React.Component<IFirstComponentProps> {
  render() {
    const { str } = this.props;

    return (
      <RenderCounter color="blue">Child Class Component "{str}"</RenderCounter>
    );
  }
}

interface ISecondComponentProps {
  num: number;
}
const SecondComponent = ({ num }: ISecondComponentProps) => (
  <RenderCounter color="green">Child Class Component {num}</RenderCounter>
);

interface IProps {
  str: string;
  num: number;
}
class ClassComponent extends Component<IProps> {
  render() {
    const { num, str } = this.props;
    return (
      <RenderCounter color="red">
        <FirstComponent str={str} />
        <SecondComponent num={num} />
      </RenderCounter>
    );
  }
}
```

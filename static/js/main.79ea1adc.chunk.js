(this["webpackJsonpreact-patterns"]=this["webpackJsonpreact-patterns"]||[]).push([[0],{31:function(e,t,n){e.exports=n(43)},42:function(e,t,n){},43:function(e,t,n){"use strict";n.r(t);var a=n(0),o=n(1),r=n.n(o),c=n(26),l=n.n(c),s=n(27),i=n.n(s),p=n(28),m=n.n(p),u=n(7),b=n(9),d=n(3),h={},j="wrapper";function O(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(j,Object.assign({},h,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Overview"),Object(a.b)("p",null,"The project is created to experiment with different approaches to use\nReact and create a list of do's, dont's, problematic approaches and best\npractice in terms of performance, readability, extensibility and\nmaintainability."))}O.isMDXComponent=!0;var g=n(4),C=function(e){var t=r.a.useState(1),n=Object(g.a)(t,2),a=n[0],o=n[1];return[function(){return o(a+1)},e?a:1]},f=function(){var e=r.a.useState(),t=Object(g.a)(e,2)[1];return function(){return t({})}},v=n(17),y=r.a.memo((function(e){var t=r.a.useRef(0);return t.current+=1,r.a.createElement("div",{style:Object(v.a)({},e.style,{borderStyle:"solid",borderWidth:3,borderColor:e.color,position:"relative",width:"70%",marginTop:4,marginBottom:4})},r.a.createElement("div",{style:{position:"absolute",right:0,top:0,background:"black",color:"white",fontFamily:"monospace",padding:2}},"Render count: ",t.current),e.children)})),N=n(11),x=n(12),E=n(14),w=n(13),S=n(15),R=function(e){function t(){return Object(N.a)(this,t),Object(E.a)(this,Object(w.a)(t).apply(this,arguments))}return Object(S.a)(t,e),Object(x.a)(t,[{key:"render",value:function(){return r.a.createElement(y,{color:"red"},"Child Class Component: ",this.props.value)}}]),t}(o.Component),k=function(e){function t(){return Object(N.a)(this,t),Object(E.a)(this,Object(w.a)(t).apply(this,arguments))}return Object(S.a)(t,e),Object(x.a)(t,[{key:"shouldComponentUpdate",value:function(e){return e.value!==this.props.value}},{key:"render",value:function(){return r.a.createElement(y,{color:"red"},"Child Class Component ",r.a.createElement("strong",null,"Memoized"),": ",this.props.value)}}]),t}(o.Component),P=(o.Component,o.Component,function(e){function t(){return Object(N.a)(this,t),Object(E.a)(this,Object(w.a)(t).apply(this,arguments))}return Object(S.a)(t,e),Object(x.a)(t,[{key:"render",value:function(){return r.a.createElement(y,{color:"green"},"Child Pure Component: ",this.props.value)}}]),t}(o.PureComponent)),T=function(e){function t(){return Object(N.a)(this,t),Object(E.a)(this,Object(w.a)(t).apply(this,arguments))}return Object(S.a)(t,e),Object(x.a)(t,[{key:"render",value:function(){return r.a.createElement(y,{color:"green"},"Child Pure Component ",r.a.createElement("strong",null,"Memoized"),": ",this.props.value)}}]),t}(o.PureComponent),M=function(e){return r.a.createElement(y,{color:"blue"},"Child Function Component: ",e.value)},F=r.a.memo((function(e){return r.a.createElement(y,{color:"blue"},"Child Function Component ",r.a.createElement("strong",null,"Memoized"),": ",e.value)})),D=function(e){var t=C(e.changeProps),n=Object(g.a)(t,2),a=n[0],o=n[1];return r.a.createElement(y,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(r.a.Fragment,null,r.a.createElement(k,{value:o}),r.a.createElement(T,{value:o}),r.a.createElement(F,{value:o})):r.a.createElement(r.a.Fragment,null,r.a.createElement(R,{value:o}),r.a.createElement(P,{value:o}),r.a.createElement(M,{value:o})),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return a()}},"Render example"))},z={},I="wrapper";function J(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(I,Object.assign({},z,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Components"),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/react-component.html"}),Object(a.b)("inlineCode",{parentName:"a"},"React.Component"))," encapsulates ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/state-and-lifecycle.html"}),"State and Lifecycle"),"."),Object(a.b)("p",null,"There are few types o the components available in React:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Class Component")," - the component which extends ",Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://reactjs.org/docs/react-api.html#reactcomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.Component"))," and uses OOP paradigms to handle state, properties, actions and manage component lifecycle. React component re-renders if the parent component got re-rendered even if no props were changed."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Pure Component")," - the ",Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://reactjs.org/docs/react-api.html#reactpurecomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.PureComponent"))," is similar to the ",Object(a.b)("inlineCode",{parentName:"li"},"React.Component"),". The difference between them is that ",Object(a.b)("inlineCode",{parentName:"li"},"React.Component")," doesn\u2019t implement ",Object(a.b)("inlineCode",{parentName:"li"},"shouldComponentUpdate()"),", but ",Object(a.b)("inlineCode",{parentName:"li"},"React.PureComponent")," implements it with a ",Object(a.b)("strong",{parentName:"li"},"shallow prop and state comparison"),"."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Function Component")," - the ",Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://reactjs.org/docs/components-and-props.html#function-and-class-components"}),Object(a.b)("inlineCode",{parentName:"a"},"React.FunctionComponent"))," is the component which takes props and renders them based on internal component logic.")),Object(a.b)("h3",null,"Regular components no props change"),Object(a.b)("p",null,"If there is no any additional work on the child components done the ",Object(a.b)("inlineCode",{parentName:"p"},"Class")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Function")," children components will re-render even if ",Object(a.b)("strong",{parentName:"p"},"no properties have been changed"),"."),Object(a.b)("p",null,"As ",Object(a.b)("inlineCode",{parentName:"p"},"Pure")," component implements shallow comparison of the props out of the box, it won't re-render."),Object(a.b)(D,{isMemoized:!1,changeProps:!1,mdxType:"Components"}),Object(a.b)("h3",null,"Regular components props change"),Object(a.b)("p",null,"If ",Object(a.b)("strong",{parentName:"p"},"any prop has been changed")," on any of the component type: ",Object(a.b)("inlineCode",{parentName:"p"},"Class"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Pure"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Function")," all of them will re-render and this is ",Object(a.b)("strong",{parentName:"p"},"expected")," behavior."),Object(a.b)(D,{isMemoized:!1,changeProps:!0,mdxType:"Components"}),Object(a.b)("h3",null,"Memoized components no props change"),Object(a.b)("p",null,'Components should be "memoized" to prevent re-rendering when no props have been changed.'),Object(a.b)("p",null,'The "memoziation" techniques described in the corresponding section of each component type.'),Object(a.b)("p",null,"The only ",Object(a.b)("inlineCode",{parentName:"p"},"Pure")," component has this functionality out of the box and no additional work for such component required."),Object(a.b)(D,{isMemoized:!0,changeProps:!1,mdxType:"Components"}),Object(a.b)("h3",null,"Memoized components props change"),Object(a.b)("p",null,"If ",Object(a.b)("strong",{parentName:"p"},"any prop has been changed")," on any of the component type: ",Object(a.b)("inlineCode",{parentName:"p"},"Class"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Pure"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Function"),' all of them will re-render even if they are "memoized" and this is ',Object(a.b)("strong",{parentName:"p"},"expected")," behavior."),Object(a.b)(D,{isMemoized:!0,changeProps:!0,mdxType:"Components"}))}J.isMDXComponent=!0;var A=function(e){var t=C(e.changeProps),n=Object(g.a)(t,2),a=n[0],o=n[1];return r.a.createElement(y,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(k,{value:o}):r.a.createElement(R,{value:o}),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:a},"Render example"))},X={},U="wrapper";function V(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(U,Object.assign({},X,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Class Component"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Class Component")," - the component which extends ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/react-api.html#reactcomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.Component"))," and uses OOP paradigms to handle state, properties, actions and manage component lifecycle. React component re-renders if the parent component got re-rendered even if no props were changed."),Object(a.b)("h3",null,"Regular Component"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildClassComponent extends Component<TValue> {\n  render() {\n    // if parent component updates this component will be re-rendered \ud83d\udca3,\n    // no matter if the props have been changed or not.\n    return (\n      <RenderCounter color="red">\n        Child Class Component: {this.props.value}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(A,{isMemoized:!1,mdxType:"ClassComponent"}),Object(a.b)("h3",null,"Solution 1: Override ",Object(a.b)("inlineCode",{parentName:"h3"},"shouldComponentUpdate()")," lifecycle method"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildClassComponentMemoized extends Component<TValue> {\n  // \u2705 place the logic to detect if component should update or not.\n  shouldComponentUpdate(nextProps: Readonly<TValue>) {\n    // \ud83d\udca1 the logic here might become very complicated,\n    // make sure you split components to the small or\n    // consider using Pure or Function components.\n    return nextProps.value !== this.props.value;\n  }\n\n  // \u2705 the component re-renders only if props have been changed.\n  render() {\n    return (\n      <RenderCounter color="red">\n        Child Class Component <strong>Memoized</strong>: {this.props.value}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(A,{isMemoized:!0,changeProps:!1,mdxType:"ClassComponent"}),Object(a.b)("p",null,"and it re-renders as expected, when props have been changes."),Object(a.b)(A,{isMemoized:!0,changeProps:!0,mdxType:"ClassComponent"}),Object(a.b)("h3",null,"Solution 2: Use Pure Component"),Object(a.b)("p",null,"Consider using Pure Component."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildPureComponent extends PureComponent<TValue> {\n  // `Pure` component implements `shouldComponentUpdate()` with a **shallow prop and state comparison**.\n  // That means no additional changes needed for the plain props.\n  // \u2705 Component does not re-render if parent component re-renders\n  // but the props have not been changed.\n  render() {\n    return (\n      <RenderCounter color="green">\n        Child Pure Component: {this.props.value}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)("p",null,"// TODO: Add example with object props"))}V.isMDXComponent=!0;var L=function(e){var t=C(e.changeProps),n=Object(g.a)(t,2),a=n[0],o=n[1];return r.a.createElement(y,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(T,{value:o}):r.a.createElement(P,{value:o}),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:a},"Render example"))},B={},W="wrapper";function $(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(W,Object.assign({},B,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Pure Component"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Pure Component")," - the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/react-api.html#reactpurecomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.PureComponent"))," is similar to the ",Object(a.b)("inlineCode",{parentName:"p"},"React.Component"),". The difference between them is that ",Object(a.b)("inlineCode",{parentName:"p"},"React.Component")," doesn\u2019t implement ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate()"),", but ",Object(a.b)("inlineCode",{parentName:"p"},"React.PureComponent")," implements it with a ",Object(a.b)("strong",{parentName:"p"},"shallow prop and state comparison"),"."),Object(a.b)("p",null,"If your React component\u2019s ",Object(a.b)("inlineCode",{parentName:"p"},"render()")," function renders the same result given the same props and state, you can use ",Object(a.b)("inlineCode",{parentName:"p"},"React.PureComponent")," for a performance boost in some cases."),Object(a.b)("h3",null,"Regular Component"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Pure")," component implements ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate()")," with a ",Object(a.b)("strong",{parentName:"p"},"shallow prop and state comparison"),".\nThat means no additional changes needed for the plain props."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildPureComponent extends PureComponent<TValue> {\n  // `Pure` component implements `shouldComponentUpdate()` with a **shallow prop and state comparison**.\n  // That means no additional changes needed for the plain props.\n  // \u2705 Component does not re-render if parent component re-renders\n  // but the props have not been changed.\n  render() {\n    return (\n      <RenderCounter color="green">\n        Child Pure Component: {this.props.value}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(L,{isMemoized:!1,mdxType:"PureComponent"}),Object(a.b)("p",null,"and it re-renders as expected, when props have been changes."),Object(a.b)(L,{isMemoized:!0,changeProps:!0,mdxType:"PureComponent"}),Object(a.b)("p",null,"// TODO: Add example with object props"))}$.isMDXComponent=!0;var H=function(e){var t=C(e.changeProps),n=Object(g.a)(t,2),a=n[0],o=n[1];return r.a.createElement(y,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(F,{value:o}):r.a.createElement(M,{value:o}),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:a},"Render example"))},_={},q="wrapper";function K(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(q,Object.assign({},_,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Function Component"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Function Component")," - the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/components-and-props.html#function-and-class-components"}),Object(a.b)("inlineCode",{parentName:"a"},"React.FunctionComponent"))," is the component which takes props and renders them based on internal component logic."),Object(a.b)("h3",null,"Regular Component"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'// Component is not memoized the parent re-render triggers this component to re-render \ud83d\udca3 too\n// even if no props have been changed.\nexport const ChildFunctionComponent: FunctionComponent<TValue> = (\n  props: TValue\n) => {\n  return (\n    <RenderCounter color="blue">\n      Child Function Component: {props.value}\n    </RenderCounter>\n  );\n};\n')),Object(a.b)(H,{isMemoized:!1,mdxType:"FunctionComponent"}),Object(a.b)("h3",null,"Solution: Memoize component with React.memo()"),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/react-api.html#reactmemo"}),Object(a.b)("inlineCode",{parentName:"a"},"React.memo"))," is a higher order component. It\u2019s similar to ",Object(a.b)("inlineCode",{parentName:"p"},"React.PureComponent")," but for function components instead of classes."),Object(a.b)("p",null,"If your function component renders the same result given the same props, you can wrap it in a call to ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo")," for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"React.memo")," only affects props changes. If your function component wrapped in ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo")," has a ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," or ",Object(a.b)("inlineCode",{parentName:"p"},"useContext")," Hook in its implementation, it will still rerender when state or context change."),Object(a.b)("p",null,"By default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can also provide a custom comparison function as the second argument."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'// \u2705 Memoize component to make sure it doesn\'t re-render, when props have been changed.\nexport const ChildFunctionComponentMemoized: FunctionComponent<TValue> = React.memo<\n  FunctionComponent<TValue>\n>((props: TValue) => {\n  return (\n    <RenderCounter color="blue">\n      Child Function Component <strong>Memoized</strong>: {props.value}\n    </RenderCounter>\n  );\n});\n')),Object(a.b)(H,{isMemoized:!0,changeProps:!1,mdxType:"FunctionComponent"}),Object(a.b)("p",null,"and it re-renders as expected, when props have been changes."),Object(a.b)(H,{isMemoized:!0,changeProps:!0,mdxType:"FunctionComponent"}),Object(a.b)("p",null,"// TODO: Add example with object props\n// TODO: Add example with useState"))}K.isMDXComponent=!0;var G={},Q="wrapper";function Y(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(Q,Object.assign({},G,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Hooks"))}Y.isMDXComponent=!0;var Z={},ee="wrapper";function te(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(ee,Object.assign({},Z,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Functions"))}te.isMDXComponent=!0;var ne=r.a.createContext({value:1}),ae=function(e){var t=r.a.useMemo((function(){return{value:1}}),[]);return r.a.createElement(y,{color:"blue"},r.a.createElement(ne.Provider,{value:t},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify(t,null,2))),r.a.createElement("div",null,e.children)))},oe=r.a.memo((function(){var e=r.a.useContext(ne);return r.a.createElement(y,{color:"green"},r.a.createElement("code",null,"Consumer: ",JSON.stringify(e,null,2)))})),re=function(){var e=f();return r.a.createElement(r.a.Fragment,null,r.a.createElement(ae,null,r.a.createElement(oe,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:e},"Render example"))},ce=r.a.createContext(0),le=r.a.createContext(0),se=function(e){var t=e.foo,n=e.bar;return r.a.createElement(y,{color:"blue"},r.a.createElement(ce.Provider,{value:t},r.a.createElement(le.Provider,{value:n},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify({foo:t,bar:n},null,2))),r.a.createElement("div",null,e.children))))},ie=r.a.memo((function(){var e=r.a.useContext(ce);return r.a.createElement(y,{color:"green"},r.a.createElement("code",null,"ConsumerFoo: ",JSON.stringify(e,null,2)))})),pe=r.a.memo((function(){var e=r.a.useContext(le);return r.a.createElement(y,{color:"red"},r.a.createElement("code",null,"ConsumerBar: ",JSON.stringify(e,null,2)))})),me=function(){var e=r.a.useState(0),t=Object(g.a)(e,2),n=t[0],a=t[1];return r.a.createElement(r.a.Fragment,null,r.a.createElement(se,{foo:n,bar:1},r.a.createElement(ie,null),r.a.createElement(pe,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return a(n+1)}},"Render example"))},ue=n(18),be=Object(ue.createContext)({foo:0,bar:0}),de=function(e){var t=e.foo,n=e.bar;return r.a.createElement(y,{color:"blue"},r.a.createElement(be.Provider,{value:{foo:t,bar:n}},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify({foo:t,bar:n},null,2))),r.a.createElement("div",null,e.children)))},he=r.a.memo((function(){var e=Object(ue.useContextSelector)(be,(function(e){return e.foo}));return r.a.createElement(y,{color:"green"},r.a.createElement("code",null,"ConsumerFoo: ",JSON.stringify(e,null,2)))})),je=r.a.memo((function(){var e=Object(ue.useContextSelector)(be,(function(e){return e.bar}));return r.a.createElement(y,{color:"red"},r.a.createElement("code",null,"ConsumerBar: ",JSON.stringify(e,null,2)))})),Oe=function(){var e=r.a.useState(0),t=Object(g.a)(e,2),n=t[0],a=t[1];return r.a.createElement(r.a.Fragment,null,r.a.createElement(de,{foo:n,bar:1},r.a.createElement(he,null),r.a.createElement(je,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return a(n+1)}},"Render example"))},ge=r.a.createContext({value:1}),Ce=function(e){var t={value:1};return r.a.createElement(y,{color:"blue"},r.a.createElement(ge.Provider,{value:t},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify(t,null,2))),r.a.createElement("div",null,e.children)))},fe=r.a.memo((function(){var e=r.a.useContext(ge);return r.a.createElement(y,{color:"green"},r.a.createElement("code",null,"Consumer: ",JSON.stringify(e,null,2)))})),ve=function(){var e=f();return r.a.createElement(r.a.Fragment,null,r.a.createElement(Ce,null,r.a.createElement(fe,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:e},"Render example"))},ye={},Ne="wrapper";function xe(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(Ne,Object.assign({},ye,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Context"),Object(a.b)("p",null,"This page covers only modern React Context API, i.e. ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/context.html"}),Object(a.b)("inlineCode",{parentName:"a"},"createContext()")),"."),Object(a.b)("h3",null,"Context behavior"),Object(a.b)("p",null,"All consumers that are descendants of a ",Object(a.b)("inlineCode",{parentName:"p"},"Provider")," will re-render whenever the ",Object(a.b)("inlineCode",{parentName:"p"},"Provider"),"\u2019s ",Object(a.b)("inlineCode",{parentName:"p"},"value")," prop changes. The propagation from ",Object(a.b)("inlineCode",{parentName:"p"},"Provider")," to its descendant consumers (including ",Object(a.b)("inlineCode",{parentName:"p"},".contextType")," on class components and ",Object(a.b)("inlineCode",{parentName:"p"},"useContext()")," hook) is not subject to the ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate()")," method or ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo()"),", so the consumer is updated even when an ancestor component skips an update."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"// \ud83d\udca1 React.memo will ignored\nconst Example = React.memo(props => {\n  // \ud83d\udca3 Updates will be triggered inside\n  const value = React.useContext(Context);\n\n  return <div />;\n});\n")),Object(a.b)("p",null,"For example the code below will trigger rerender always as ",Object(a.b)("inlineCode",{parentName:"p"},"context")," object will be always newly created."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const Example = props => {\n  const { children } = props;\n  // \u26d4 ({ value: 1 } === { value: 1 }) is false, so reference is different\n  const context = { value: 1 };\n\n  return <Provider value={context}>{children}</Provider>;\n};\n")),Object(a.b)(ve,{mdxType:"ContextUnmemoizedExample"}),Object(a.b)("h3",null,"Solution 1: Use memoized context value"),Object(a.b)("p",null,"If value is changing rarely is good option to memoize an object value with ",Object(a.b)("inlineCode",{parentName:"p"},"useMemo()")," hook."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const Example = props => {\n  const { children, value } = props;\n  // \u2705 Now new `context` will be recreated only on `value` change\n  const context = React.useMemo(() => ({ value }), [value]);\n\n  return <Provider value={context}>{children}</Provider>;\n};\n")),Object(a.b)(re,{mdxType:"ContextMemoized"}),Object(a.b)("p",null,"For class components you can use ",Object(a.b)("inlineCode",{parentName:"p"},"this.state"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"class Example extends React.Component {\n  render() {\n    return <Provider value={this.state}>{children}</Provider>;\n  }\n}\n")),Object(a.b)("h3",null,"Solution 2: Use separate contexts"),Object(a.b)("p",null,"This trick was ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://kentcdodds.com/blog/how-to-use-react-context-effectively"}),"described")," by Kent Dodds. Idea is to pass plain/memoized\nvalues in separate contexts to avoid useless notifications to subscribers."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const Example = props => {\n  const { children } = props;\n\n  // \u2757 both values are plain and safe for shallow compare\n  const firstValue = 1;\n  const secondValue = 2;\n\n  return (\n    <FirstProvider value={firstValue}>\n      <SecondProvider value={secondValue}>{children}</SecondProvider>\n    </FirstProvider>\n  );\n};\n")),Object(a.b)(me,{mdxType:"ContextSeparate"}),Object(a.b)("h3",null,"Solution 3: Experimental bits API"),Object(a.b)("p",null,"React provides an expiremental API with ",Object(a.b)("inlineCode",{parentName:"p"},"calculateChangedBits")," & ",Object(a.b)("inlineCode",{parentName:"p"},"calculateChangedBits"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"function createContext<T>(defaultValue: T, calculateChangedBits?: (prev: T, next: T) => number): Context<T>;\nfunction useContext<T>(context: Context<T>, observedBits?: number|boolean): T;\n")),Object(a.b)("p",null,"Which allows to change default behavior of Context API and avoid useless rerenders. As it's experimental there are no official docs yet, check ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://medium.com/@leonardobrunolima/react-tips-context-api-performance-considerations-d964f3ad3087"}),"this article")," to get more details."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"changedBits === 0")," has a ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/facebook/react/blob/9b0bd43550206e04bfe9ca695e5981eff0e2d03f/packages/react-reconciler/src/ReactFiberBeginWork.js#L2304"}),"special handling")," in ",Object(a.b)("inlineCode",{parentName:"p"},"react-reconciler"),", so the simplest and interesting trick is to disable any consumer's updates:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"// \u2620\ufe0f Even is `value` will change updates will be silenced\nconst Context = React.createContext(value, () => 0);\n")),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://www.npmjs.com/package/use-context-selector"}),Object(a.b)("inlineCode",{parentName:"a"},"use-context-selector"))," uses ",Object(a.b)("inlineCode",{parentName:"p"},"changedBits === 0")," to implement selector-like API for hooks which currently stays as an ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/reactjs/rfcs/pull/119"}),"open RFC"),"."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const Example = React.memo(props => {\n  // \u2705 Updates of other context properties will be ignored\n  const locale = useContextSelector(LocaleContext, v => v.locale);\n\n  return <div>Current locale is {locale}.</div>;\n});\n")),Object(a.b)(Oe,{mdxType:"ContextSelectorExample"}),Object(a.b)("p",null,"There is also a lot of custom context/global state implementations, comparison\nfor Concurrent mode ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-mode"}),"available there"),"."))}xe.isMDXComponent=!0;var Ee={},we="wrapper";function Se(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)(we,Object.assign({},Ee,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"State Immutability in React, why it is important, and how to achieve it using Immer"),Object(a.b)("p",null,"React ",Object(a.b)("em",{parentName:"p"},"props")," and ",Object(a.b)("em",{parentName:"p"},"state")," are readonly by contract; it is, however, very easy to break this contract\nand introduce issues that are difficult to debug. In order to prevent these issues it is advised not\nto mutate state unless necessary. If non-trivial mutation of the current state is unvoidable, it is\nadvised to use an immutability helper called Immer."),Object(a.b)("p",null,"In the text below we start with a piece of code\nthat doesn't work, we transform it into code that works, but is error-prone and unreadable, and eventually\nwe reach the state of well readable and easily maintainable code. As we go over these phases\nwe gradually build a case for using Immer."),Object(a.b)("h3",null,"State mutation outside of setState mechanism"),Object(a.b)("p",null,"React ",Object(a.b)("em",{parentName:"p"},"state")," is declared readonly, but that only means that the ",Object(a.b)("em",{parentName:"p"},"reference")," to it is constant. This\neffectively protects primitives from being changed, but it doesn't protect objects. The only sound\nmeans of state change in React is the ",Object(a.b)("em",{parentName:"p"},"setState")," method and any code that asserts it is correct in doing so.\nIn the example below, the ",Object(a.b)("em",{parentName:"p"},"sumData"),' function rightfully asserts that the state object will not change\nand based on that it caches its output based on the state object\'s internal field "data".'),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState({ data: [0, 0] });\n\n  // Assert state immutability.\n  const data = state.data;\n  const sumData = React.useCallback(\n    () => data.reduce((acc, val) => acc + val, 0),\n    [data]\n  );\n\n  const run = () => {\n    // State mutated.\n    state.data = [1, 1];\n    // Sum is out of sync.\n    state.data.push(sumData());\n    state.data.push(sumData());\n    state.data.push(sumData());\n    setState({ data: state.data });\n  };\n")),Object(a.b)("p",null,"However, the ",Object(a.b)("em",{parentName:"p"},"run")," function changes the state object -- its internal field ",Object(a.b)("em",{parentName:"p"},"data")," now points to a\ndifferent address. ",Object(a.b)("em",{parentName:"p"},"sumData")," captures the original address (that wasn't supposed to change), and therefore\nit will sum the original data."),Object(a.b)("p",null,"The logical step in rectifying this seems to be to make ",Object(a.b)("em",{parentName:"p"},"sumData")," capture the entire state -- since it is\nreadonly we will be sure that we always refer to the correct address. It also seemingly makes sense not to construct\na new state object in ",Object(a.b)("em",{parentName:"p"},"run")," since we only change a single field inside of it:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState({ data: [0, 0] });\n\n  // Assert state immutability.\n  const sumData = React.useCallback(\n    () => state.data.reduce((acc, val) => acc + val, 0),\n    [state]\n  );\n\n  const run = () => {\n    // State mutated.\n    state.data = [1, 1];\n    // Sum is in sync.\n    state.data.push(sumData());\n    state.data.push(sumData());\n    state.data.push(sumData());\n    setState(state);\n  };\n")),Object(a.b)("p",null,"The issue with this change is that now it doesn't work at all, because React asserts that since the\naddress of the state object hasn't changed, the object itself hasn't changed, and it will ignore the\nsetState call. The obvious solution is to copy the object:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState({ data: [0, 0] });\n\n  // Assert state immutability.\n  const sumData = React.useCallback(\n    () => state.data.reduce((acc, val) => acc + val, 0),\n    [state]\n  );\n\n  const run = () => {\n    state.data = [1, 1];\n    // Contract violation.\n    state.data.push(sumData());\n    state.data.push(sumData());\n    state.data.push(sumData());\n    setState({...state});\n  };\n")),Object(a.b)("p",null,'Now the code will work. The issue with this code, however, is that it is breaking the immutability contract\nwith React and that it is prone to error. If the state object were to consist of multiple nested fields,\nwe would have to make sure that the object is copied properly to form a new state. Since there is no native\nconcept of "deep copy" in javascript, doing this can be rather cumbersome:'),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState(getCumbersomeState());\n\n  const getStateString = React.useCallback(() => JSON.stringify(state), [\n    state\n  ]);\n\n  const updateJillsStreet = () => {\n    // It is easy to get lost in this sea of spread operators and brackets.\n    setState(prevState => ({\n      people: [\n        { ...prevState.people[0] },\n        {\n          ...prevState.people[1],\n          addresses: [\n            {\n              ...prevState.people[1].addresses[0],\n              street: `Street ${Math.random()}`\n            }\n          ]\n        }\n      ]\n    }));\n  };\n\n  return (\n    <div className="App">\n      <div>{getStateString()}</div>\n      <div>\n        <button onClick={updateJillsStreet}>updateJillsStreet</button>\n      </div>\n    </div>\n  );\n};\n')),Object(a.b)("h3",null,"Immer.js to the rescue"),Object(a.b)("p",null,"And that is when Immer.js comes to the rescue. Immer.js uses ES6 proxies (note that when transcompiled to ES5\nit will become much slower) to record changes to a so called ",Object(a.b)("em",{parentName:"p"},"draft")," object during the execution of the ",Object(a.b)("em",{parentName:"p"},"produce"),"\nfunction and then project them onto a new object that becomes the new state. The ",Object(a.b)("em",{parentName:"p"},"draft")," object is based on the existing\nstate that is passed to the ",Object(a.b)("em",{parentName:"p"},"produce")," function along with the draft callback. The following snippet demonstrates\nhow we go from cumbersome, ugly, and ureadable to straightforward, beautiful, and well readable:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState(getCumbersomeState());\n\n  const getStateString = React.useCallback(() => JSON.stringify(state), [\n    state\n  ]);\n\n  const updateJillsStreet = () => {\n    setState(\n      produce(state, _draft => {\n        _draft.people[1].addresses[0].street = `Street ${Math.random()}`;\n      })\n    );\n  };\n\n  return (\n    <div className="App">\n      <div>{getStateString()}</div>\n      <div>\n        <button onClick={updateJillsStreet}>updateJillsStreet</button>\n      </div>\n    </div>\n  );\n};\n')),Object(a.b)("p",null,"This can be further simplified by using the ",Object(a.b)("em",{parentName:"p"},"use-immer")," npm package that provides us with a hook\nthat combines the native ",Object(a.b)("em",{parentName:"p"},"React.useState")," and Immer's ",Object(a.b)("em",{parentName:"p"},"produce"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'export const Component: React.FunctionComponent = props => {\n  const [state, setState] = useImmer(getCumbersomeState());\n\n  const getStateString = React.useCallback(() => JSON.stringify(state), [\n    state\n  ]);\n\n  const updateJillsStreet = () => {\n    setState(_draft => {\n      _draft.people[1].addresses[0].street = `Street ${Math.random()}`;\n    });\n  };\n\n  return (\n    <div className="App">\n      <div>{getStateString()}</div>\n      <div>\n        <button onClick={updateJillsStreet}>updateJillsStreet</button>\n      </div>\n    </div>\n  );\n};\n')),Object(a.b)("p",null,"In the newly created state, fields that didn't change during the execution of the draft callback\nwill be referentially equal to the fields in the original state. Only fields that were changed\nin the draft and the root object will be new objects."),Object(a.b)("h3",null,"Resources"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://immerjs.github.io/immer/docs/introduction"}),"https://immerjs.github.io/immer/docs/introduction"))))}Se.isMDXComponent=!0;var Re=function(){return r.a.createElement(u.a,null,r.a.createElement("div",{className:"wrapper"},r.a.createElement("header",null,r.a.createElement("h1",null,"React Patterns")),r.a.createElement("div",{className:"main"},r.a.createElement("aside",null,r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement(u.b,{to:"/"},"Overview")),r.a.createElement("li",null,r.a.createElement(u.b,{to:"/components"},"Components"),r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement(u.b,{to:"/class-component"},"Class Component")),r.a.createElement("li",null,r.a.createElement(u.b,{to:"/pure-component"},"Pure Component")),r.a.createElement("li",null,r.a.createElement(u.b,{to:"/function-component"},"Function Component")))),r.a.createElement("li",null,r.a.createElement(u.b,{to:"/hooks"},"Hooks")),r.a.createElement("li",null,r.a.createElement(u.b,{to:"/context"},"Context")),r.a.createElement("li",null,r.a.createElement(u.b,{to:"/functions"},"Functions")),r.a.createElement("li",null,r.a.createElement(u.b,{to:"/immutability"},"Immutability")))),r.a.createElement("main",null,r.a.createElement(r.a.Suspense,{fallback:r.a.createElement("div",null,"Loading...")},r.a.createElement(b.c,null,r.a.createElement(b.a,{path:"/components",component:J}),r.a.createElement(b.a,{path:"/class-component",component:V}),r.a.createElement(b.a,{path:"/pure-component",component:$}),r.a.createElement(b.a,{path:"/function-component",component:K}),r.a.createElement(b.a,{path:"/hooks",component:Y}),r.a.createElement(b.a,{path:"/context",component:xe}),r.a.createElement(b.a,{path:"/functions",component:te}),r.a.createElement(b.a,{path:"/immutability",component:Se}),r.a.createElement(b.a,{exact:!0,path:"/",component:O}))))),r.a.createElement("footer",null,"\xa9 2019, Sergii Mykhailov. ",r.a.createElement(u.b,{to:"/"},"React Patterns"))))},ke=n(22),Pe=(n(41),{code:function(e){var t=e.className,n=void 0===t?"language-jsx":t,a=e.children,o=void 0===a?"":a,c=n.replace("language-",""),l=o.replace(/\n$/,"");return r.a.createElement(r.a.Fragment,null,r.a.createElement("style",null,".prism-code .token.plain { display: inline-block; }"),r.a.createElement("style",null,".prism-code .token.comment { font-style: normal; }"),r.a.createElement(ke.a,Object.assign({},ke.b,{code:l,language:c,theme:void 0}),(function(e){var t=e.className,n=e.style,a=e.tokens,o=e.getLineProps,c=e.getTokenProps;return r.a.createElement("pre",{className:t,style:Object(v.a)({},n,{padding:3})},a.map((function(e,t){return r.a.createElement("div",o({line:e,key:t}),e.map((function(e,t){return r.a.createElement("span",c({token:e,key:t}))})))})))})))}});Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));n(42);new i.a(m.a).injectStyles(),l.a.render(r.a.createElement(a.a,{components:Pe},r.a.createElement(Re,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))}},[[31,1,2]]]);
//# sourceMappingURL=main.79ea1adc.chunk.js.map